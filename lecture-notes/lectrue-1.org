#+title: 第一讲：第一个问题
#+author: 独不迁
#+date: 2023-01-14
#+OPTIONS: broken-links:t

* 一个问题

是的！这门课的风格就是这样------用一个问题作为开头，然后我们一步一步的解决问题，这也是我最为鼓励的学习方式：从解决各种问题中学习足够的知识。

那么来看看我们的第一个问题：

*问题 1：* 请在终端模拟器中输出 Hello World。

* Shell
真是相当经典的题目！这时候你可能会疑惑------什么是终端模拟器？在这里。让我们引入一个概念，就是 *shell*。用不太严谨的方法定义，shell 就是操作系统提供给我们的，可以使用文字来操作的接口。 在目前常用的各种操作系统中，例如 Windows，MacOS（OS X），和各种 /NIX 系统和其发行版，一般都会提供 shell 接口------例如 Windows 中有 cmd 和 powershell，Mac OS 和其他 /NIX 系统以及其发行版常用的 bash，又或者 ksh 等等。如果你使用的操作系统带有一个图形用户界面（GUI），那么一般会提供一个终端模拟器，用来给用户开放使用 shell。例如 Windows 下面的 Windows Terminal，*NIX 根据使用不同的图形用户界面，也会有不同的终端模拟器，例如 GNOME 一般会自带一个 GNOME Terminal，KDE 则会有一个 Konsole。

本文会以最常用的 *bash* 作为例子，并且会在 [[#][附录一]] 中讲解常用的 bash 操作，以及编写 bash 脚本。但如果你是使用的 Windows，那么也不用担心，因为我在本书中使用的指令，在安装好对应程序，并且正确设置好环境变量，都是可以直接使用的。当然你也可以使用 *WSL*，也即是 Windows Subsystem for Linux，这是一个可以运行在 Windows 中的子系统，这也是我最为推荐（和鼓励）的方法。WSL 的安装以及配置都非常简单，读者可以参照 [[link:https://learn.microsoft.com/en-us/windows/wsl/install][微软官方的文档]] 来进行安装配置。

* 编写程序的工具
那么，我们终于要开始编写我们的程序了！这时候便又出现了一个新问题：我们用什么来编写程序？

想想我们平时是使用什么软件来编辑文本的------记事本？Microsoft Word？这些可以用来编写和编辑我们的代码吗？当然可以！但是会很麻烦，并且会使你的编写和阅读体验糟糕透顶。

专业的代码编辑器和集成开发环境都会提供让程序设计者十分舒适的体验，例如由捷克公司 JetBrains 制作的各种集成开发环境，如 Intellij IDEA，CLion，又或者微软公司 "巨无霸" 的 Visual Studio 以及 编辑器 Visual Stuidio Code。又或者老一些的极客们更喜欢用的 Vim 和 Emacs。本书不对编辑器和集成开发环境做什么要求。而我也推荐大家使用各种文本编辑器和集成开发环境，选出一个你最喜欢的使用，以此来最大化效率。

* 编写程序！
那么！打开你最喜欢的编辑器或集成开发环境，输入以下内容吧：

#+begin_src C
  # include <stdio.h>

  int main() {
      printf("Hello World");
      return 0;
  }
#+end_src

并且保存为 hello.c

* 然后？
然后！然后......然后？我们保存，退出，没有任何事情发生。或许你觉得写代码就像使用一个魔咒，大声念出 "阿瓦达索命！" 便能施放出来。但让人痛苦的是------我们的计算机并不是魔法世界的产物，它是由呆瓜们制造的比呆瓜更呆瓜的工具。所以我们也要用对待呆瓜的方法让计算机看懂我们的 "咒语"。

其实，就像本书的读者一般说中文，而英国人一般说英语，法国人一般说法语一样，每个当代人一般都有自己的母语。而当代计算机的的母语便是二进制。如果您阅读过 [[file:#][第零章]] 的话，应该对为何采用二进制并不陌生。

所以如果直接给我们的计算机阅读我们写的 C 语言程序，如同对着一个罗马人说法语，到头来肯定会鸡同鸭讲。所以我们需要一个 *翻译* 来将法语翻译成拉丁语——也就像将 C 程序翻译成二进制程序一样。而这里，我们的翻译员就叫做 *编译器* 。

市面上有很多不同的编译器可以选择，常用的有 GNU 的 gcc，微软的 MSVC，和本文会使用的 clang。

就像我在前文中提到的 *翻译* 的工作一样。我们的编译器会首先读入一个 *源文件* ，在我们的语境中也就是 C 语言的源文件。这时候我们的编译器就会着手翻译工作。

*输入源文件 -> 编译器 -> 可执行文件*

这只是一个简略的表示，事实上编译器是一个相当有意思的软件。我们会在将来用一整门课（编译原理）来讲解它。

不同的翻译官有不同的翻译习惯，gcc, clang, MSVC 可能会翻译出不同可执行文件，但一般都会实现相同的效果，不过会在运行速度、文件大小上有所区别。有的翻译官会更多的单词和语句，而有的翻译官不会，所以有的时候你的程序用 clang 可以成功编译，但是使用 MSVC 却不可以编译通过的时候，很有可能就是你写了一些 clang 认识而 MSVC 不认识的 “单词”。

* 运行！
那么我们了解了什么是编译器，就让我们使用我们的编译器编译我们的程序，然后运行起来吧！

#+begin_src sh
  clang hello.c -o hello
#+end_src

如果您使用的 Windows 可以这么写：
#+begin_src sh
  clang hello.c -o hello.exe
#+end_src

下文将统一采用上面的写法，请使用 Windows 的读者自行转换。

然后键入：

#+begin_src sh
  ./hello
#+end_src

终于！我们可以看见我们的终端模拟器上出现了：
#+begin_src sh
  Hello World
#+end_src

我们便完成了我们的任务。

那么接下来，让我们逐行地分析一下我们的程序吧。


* 我们写了些什么呢？
#+begin_src C
  # include <stdio.h>

  int main() {
      printf("Hello World");
      return 0;
  }
#+end_src

首先我们来看第一行，在这里我们使用了关键词 =#include= ，正如它的名字一样，它的作用便是 “引入” 它后面尖括号中的东西，在这里我们引入了 =stdio.h= ，它的文件后缀名 =.h= 代表它是一个 header 文件，中文一般翻译为 “头文件”。我们不妨将程序设计当作是建筑，头文件相当于一个 “工具箱”。所以在这一行，我们便是带着我们的 “工具箱”，走进 “施工现场”。

在第三行中，这是一个暂时需要你 “死记硬背” 的东西，不过我们很快就会在 [[file:#][第五讲]] 接触到这个概念。我们叫它为 *主函数* 。它相当于我们 “施工现场的入口”。我们的程序会从这行开始运行。

第四行我们便使用了 =stdio.h= 中提供的工具： =printf= 。print 是打印的意思，相信大家都很熟悉，后面的 f 为 “format”，意思就是 “按照格式输出”。为什么需要 “格式”？很快你便会了解了！它的用法也很简单，就是将后面括号中的东西打印出来，在这里因为我们输出的一串字符（字符串），所以我们需要用大括号包裹起来。感觉有些疑惑？什么是字符？什么是 “字符串”？别担心！很快你就会知道！在 [[file:lecture-notes/lecture-2.org][第二讲]] 中，我们很快就会提到。

第五行的 =return 0= 并不是必须的，你可以试试删掉这一行，它依然可以正常运行。 =return 0= 在这里的作用是代表我们的程序顺利运行。

好了，这里留一个小练习：你可以将第四行引号内的内容更改成你自己喜欢的句子，看看会怎么输出。

* 输出和格式
上一节中我们讲解了输出和格式。在这里就让我们看一下 =printf= 的更多 “玩法”。

我们可以直接输出数字！像是这样：
#+begin_src C
  # include <stdio.h>

  int main() {
      printf("%d", 1);
      return 0;
  }
#+end_src

这里 =%d= 我们称之为 “逃逸字符”，其实也很形象，你可以试试编译并且运行上面的程序，你会发现输出了 “1”，就像是留下了一个记号，然后真正输出的东西先 “逃逸了” 出去一样。这里的 ‘d’ 也就是 “decimal number”——十进制数。不然你也试试？将这里的 “1” 改成其他数字，看看会发生什么？

既然有 decimal number，那也应该会有别的格式，让我们试一试字符吧：
#+begin_src C
  # include <stdio.h>

  int main() {
      printf("%c", 'c');
      return 0;
  }
#+end_src

这里的 ‘c’ 就是 “character” 的首字母。而我们要表示字符则需要使用单引号来包裹住，代表包裹在其中的是字符。字符字符，也就是一个 ASCII 字符，什么？不理解什么是 ASCII 吗？别担心哦，这个概念在下一节便会讲解了！

输出一个字符可能就有些局限，让我们试试别的吧：
#+begin_src C
  # include <stdio.h>

  int main() {
      printf("%s", "Hello World");
      return 0;
  }
#+end_src

字符串的情况，我们上文中已经提到了，让我们用逃逸字符的版本来看一看吧。这里的 ‘s’ 也是 “string”。字符串的名字也很形象——把一堆字符 “串在一起” 就是，就是字符串了。

那么这一节就是这样了。还记得本节开头提出的问题吗？希望你已经基本理解这道问题了。接下来就需要你不断地练习——给自己提出新问题，然后自己解决——例如不输出 “Hello World”，输出一些你喜欢的句子、如果用 “%d” 输出小数为发生什么？请不断尝试吧！让你的手脏起来（Get your hands dirty）!
